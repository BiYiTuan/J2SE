
1.线程同步 synchronized

线程的同步是为了防止多个线程访问一个数据对象时，对数据造成破坏。
定义线程同步的机制是 synchronized 关键字，它包括两种用法: synchronized 方法和 synchronized 块。

------------------------------------------------------------------------------------------------------
2.锁

Java中每个对象都有一个内置锁。当程序运行到非静态的synchronized同步方法上时，自动获得与正在执行代码类的
当前实例(this实例)有关的锁。获得一个对象的锁也称为获取锁、锁定对象、在对象上锁定或在对象上同步。

当程序运行到synchronized同步方法或代码块时该对象锁才起作用。

一个对象只有一个锁。所以，如果一个线程获得该锁，就没有其他线程可以获得锁，直到第一个线程释放(或返回)锁。
这也意味着任何其他线程都不能进入该对象上的synchronized方法或代码块，直到该锁被释放。

释放锁是指持锁线程退出了synchronized同步方法或代码块。

注意:
1)如果两个线程要执行一个类中的synchronized方法，并且两个线程使用相同的实例来调用方法，那么一次只能有一
个线程能够执行方法，另一个需要等待，直到锁被释放。也就是说: 如果一个线程在对象上获得一个锁，就没有任何其
他线程可以进入该对象中的任何一个同步方法。
2)线程睡眠时，它所持的任何锁都不会释放。
3)线程可以获得多个锁。比如，在一个对象的同步方法里面调用另外一个对象的同步方法，则获取了两个对象的同步锁。
4)同步损害并发性，应该尽可能缩小同步范围。
5)在使用同步代码块时候，应该指定在哪个对象上同步，也就是说要获取哪个对象的锁。

如果线程试图进入同步方法，而其锁已经被占用，则线程在该对象上被阻塞。

锁会降低效率。

------------------------------------------------------------------------------------------------------
3.静态方法同步

要同步静态方法，需要一个用于整个类对象的锁，这个对象是就是这个类（XXX.class)。

例如:
public static synchronized int setName(String name){
      Xxx.name = name;
}

等价于
public static int setName(String name){
      synchronized(Xxx.class){
            Xxx.name = name;
      }
}

注意:
1.调用同一个对象中非静态同步方法的线程将彼此阻塞。如果是不同对象，则每个线程有自己的对象的锁，线程间彼此
互不干预。
2.调用同一个类中的静态同步方法的线程将彼此阻塞，它们都是锁定在相同的Class对象上。
3.静态同步方法和非静态同步方法将永远不会彼此阻塞，因为静态方法锁定在Class对象上，非静态方法锁定在该类的
对象上。

------------------------------------------------------------------------------------------------------
线程安全

如果一个类已经很好的同步以保护它的数据时，这个类就称为"线程安全的"。
即使是线程安全类，也应该特别小心，因为操作的线程之间(程序)仍然不一定安全。

------------------------------------------------------------------------------------------------------
线程死锁

当两个线程被阻塞，每个线程在等待另一个线程时就发生死锁。

解决死锁的办法: 增大锁定的粒度(锁定整个对象)等。

------------------------------------------------------------------------------------------------------
小结

1.线程同步的目的是为了保护多个线程访问一个资源时对资源的破坏。
2.线程同步方法是通过锁来实现，每个对象都有且仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，
其他访问该对象的线程就无法再访问该对象的其他同步方法。
3.对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。静态和非静态方法的锁互不干预。一个线程获得
锁，当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁。
4.编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对"原子"操作做出分析，
并保证原子操作期间别的线程无法访问竞争资源。





