
线程调度

线程调度是Java多线程的核心，只有良好的调度，才能充分发挥系统的性能，提高程序的执行效率。

但是要明确，不管程序员怎么编写调度，只能最大限度的影响线程执行的次序，而不能做到精准控制。

-----------------------------------------------------------------------------------------------------
1.休眠

线程休眠的目的是使线程让出CPU的最简单的做法之一，线程休眠时，会将CPU资源交给其他线程，以便能轮换执行，
当休眠一定时间后，线程会苏醒，进入准备状态等待执行。

线程休眠的方法是 Thread.sleep(long millis) 和 Thread.sleep(long millis, int nanos)。

简单说，哪个线程调用sleep，就休眠哪个线程。


2.优先级

与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，
优先级低的并非没机会执行。

线程的优先级用1-10之间的整数表示，数值越大优先级越高，默认的优先级为5。
在一个线程中开启另外一个新线程，则新开线程称为该线程的子线程，子线程初始优先级与父线程相同。

Thread t1 = new MyThread1();
t1.setPriority(10);


3.让步

线程的让步就是使当前运行着的线程让出CPU资源，但是让给谁不知道，仅仅是让出，线程状态回到可运行状态。

线程的让步使用Thread.yield()方法，yield()为静态方法，功能是暂停当前正在执行的线程对象，并执行其他线程。


4.合并

线程的合并就是将几个并行运行的线程合并为一个单线程执行，应用场景是当一个线程必须等待另一个线程执行完毕后
才能执行时可以使用 join 方法。

join为非静态方法，定义如下：

void join()  等待该线程终止。    
void join(long millis)  等待该线程终止的时间最长为 millis毫秒。    
void join(long millis, int nanos)  等待该线程终止的时间最长为 millis毫秒 + nanos 纳秒。


5.守护线程

守护线程与普通线程写法上基本没有区别，调用线程对象的方法 setDaemon(true)，则可以将其设置为守护线程。

守护线程使用的情况较少，但并非无用，举例来说，JVM的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据
库应用时，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。

设置守护线程的方法:
public final void setDaemon(boolean on)
将该线程标记为守护线程。当正在运行的线程都是守护线程时，JVM退出(没有执行完的后台线程将不会再执行)。注意，
该方法必须在启动线程前调用。该方法首先调用该线程的 checkAccess方法，可能抛出 SecurityException。

注意:
JRE判断程序是否执行结束的标准是所有的前台线程执行完毕了，而不管后台线程的状态，因此，在使用后台线程的时候
一定要注意这个问题。

