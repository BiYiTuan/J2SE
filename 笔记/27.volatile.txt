
volatile

volatile 用在多线程，同步变量。线程为了提高效率，将某成员变量(如A)拷贝了一份(如B)，线程中对A的访问其实访问的是B。
只在某些动作时才进行A和B的同步。因此存在A和B不一致的情况。volatile就是用来避免这种情况的。

volatile 所修饰的变量不保留拷贝，直接访问主内存中的(也就是上面说的A)。

volatile 一般情况下不能代替 sychronized，因为 volatile 不能保证操作的原子性，即使只是i++，实际上也是由多个原子操作
组成: read i; inc; write i，假如多个线程同时执行i++，volatile只能保证他们操作的i是同一块内存，但依然可能出现写入
脏数据的情况。如果配合Java 5增加的 atomic wrapper classes，对它们的increase之类的操作就不需要sychronized。

volatile是变量修饰符，而 synchronized 作用于一段代码或方法。

volatile关键字用于声明简单类型变量，如int、float、boolean等数据类型。
如果这些简单数据类型声明为volatile，对它们的操作就会变成原子级别的。

在使用volatile关键字时要慎重，并不是只要简单的把类型变量使用volatile修饰，对这个变量的所有操作都会成为原子操作，
当变量的值由自身的上一个值决定时，如 n=n+1、n++ 等，volatile关键字将失效，只有当变量的值和自身上一个值无关时对该
变量的操作才是原子级别的，如 n=m+1，这个就是原子级别的。所以在使用volatile关键时一定要谨慎，如果自己没有把握，可
以使用synchronized来代替volatile。

volatile只保证可见性，不保证原子性！

public class TestVolatile {
	// 加上volatile
	public static volatile int count3 = 0;

	public static void inc() {
		count3++;
	}

	public static void main(String[] args) throws InterruptedException {
		for (int i = 0; i < 1000; i++) {
			new Thread(new Runnable() {
				@Override
				public void run() {
					try {
						Thread.sleep(1);
					} catch (InterruptedException e) {
					}

					inc();
				}
			}).start();
		}

		Thread.sleep(2000);

		// 运行结果依然不是我们期望的1000
		System.out.println("运行结果: count3=" + TestCounter3.count3);
	}
}

public class TestVolatile2 {
	public static volatile boolean flag5 = false;

	public static void main(String[] args) throws InterruptedException {
		for (int i = 0; i < 10; i++) {
			new Thread(new Runnable() {
				@Override
				public void run() {
					for (int i = 0; i < 100; i++) {
						try {
							Thread.sleep(1);
						} catch (InterruptedException e) {
						}

						flag5 = i % 2 == 0 ? true : false;
					}
				}
			}).start();
		}

		// 保证所有的线程都执行完毕
		Thread.sleep(2000);

		// 运行结果是我们期望的false，测试通过！
		System.out.println("运行结果: flag5=" + TestFlag5.flag5);
	}
}



http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html
http://www.cnblogs.com/zhengbin/p/5654805.html
