

1.synchronized 

同步块，通过 synchronized 关键字来实现，所有加上 synchronized 的块语句，在多线程访问的时候，
同一时刻只能有一个线程调用。
synchronized 可以修饰 方法 或者 代码块。

2.volatile

用volatile修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最新的值。


volatile 一般情况下不能代替 sychronized，因为 volatile 不能保证操作的原子性，即使只是i++，
实际上也是由多个原子操作组成: read i; inc; write i，假如多个线程同时执行i++，volatile只能
保证他们操作的i是同一块内存，但依然可能出现写入脏数据的情况。如果配合Java 5增加的 atomic 
wrapper classes，对它们的increase之类的操作就不需要sychronized。


synchronized 和 volatile比较:
1.volatile 是变量修饰符，而 synchronized 作用于一段代码或方法。
2.volatile 不需要加锁，比synchronized更轻量级,不会阻塞线程。
3.synchronized 既能保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性。

-------------------------------------------------------------------------------------------

volatile 很容易被误用来进行原子性操作。但是它只能保证可见性，不保证原子性！

在 java 垃圾回收中，描述了jvm运行时内存的分配。其中有一个内存区域是jvm栈，每一个线程运行
时都有一个线程栈，线程栈保存了线程运行时候变量值信息。当线程访问某一个对象的值的时候，首
先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的值load到线程本地内存中，建
立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，
在修改完之后的某一个时刻(线程退出之前)，自动把线程变量副本的值回写到对象在堆中变量。这样
在堆中的对象的值就产生变化了。

对于volatile修饰的变量，jvm只是保证从主内存加载到线程工作内存的值是最新的。


