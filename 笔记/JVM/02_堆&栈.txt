
堆与栈

堆(heap)和栈(stack)是程序运行的关键。

1.栈是运行时的单位，而堆是存储的单位。
栈解决程序的运行问题，即程序如何执行，或者说如何处理数据;
堆解决的是数据存储的问题，即数据怎么放、放在哪儿。

在Java中，一个线程就会相应有一个线程栈与之对应，因为不同的线程执行逻辑有所不同，
因此需要一个独立的线程栈。而堆则是所有线程共享的。栈因为是运行单位，因此里面存
储的信息都是跟当前线程(或程序)相关的。包括局部变量、程序运行状态、方法返回值等等；
而堆只负责存储对象信息。

2.为什么要把堆和栈区分出来呢? 栈中不是也可以存储数据吗?
第一，栈代表了处理逻辑，而堆代表了数据。这样分开，使得处理逻辑更为清晰。分而治之的思想。
这种隔离、模块化的思想在软件设计的方方面面都有体现。

第二，堆与栈的分离，使得堆中的内容可以被多个栈共享(也可以理解为多个线程访问同一个对象)。
这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，
堆中的共享常量和缓存可以被所有栈访问，节省了空间。

第三，栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，
因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，
使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。

第四，面向对象就是堆和栈的完美结合。其实，面向对象方式的程序与以前结构化的程序在执行上没有任何
区别。但是，面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们
把对象拆开，你会发现，对象的属性其实就是数据，存放在堆中；而对象的行为(方法)，就是运行逻辑，
放在栈中。我们在编写对象的时候，其实即编写了数据结构，也编写了处理数据的逻辑。

在Java中，Main函数就是栈的起始点，也是程序的起始点。

3.堆中存什么? 栈中存什么?
堆中存的是对象。栈中存的是基本数据类型和堆中对象的引用。一个对象的大小是不可估计的，或者说是可以
动态变化的，但是在栈中，一个对象只对应了一个4btye的引用(堆栈分离的好处)。

4.为什么不把基本类型放堆中呢?
因为其占用的空间一般是1~8个字节(需要空间比较少)，而且因为是基本类型，所以不会出现动态增长的情况(长度固定)，
因此栈中存储就够了，如果把他存在堆中是没有什么意义的(还会浪费空间)。可以这么说，基本类型和对象的引用都是
存放在栈中，而且都是几个字节的一个数，因此在程序运行时，他们的处理方式是统一的。但是引用类型、对象引用和对
象本身就有所区别了，因为一个是栈中的数据，一个是堆中的数据。最常见的一个问题就是，Java中参数传递时的问题。

5.Java中的参数传递时传值呢? 还是传引用?
要说明这个问题，先要明确两点:
1.不要试图与C进行类比，Java中没有指针的概念;
2.程序运行永远都是在栈中进行的，因而参数传递时，只存在传递基本类型和对象引用的问题。不会直接传递对象本身。
明确以上两点后。Java在方法调用传递参数时，因为没有指针，所以它都是进行传值调用。
在运行栈中，基本类型和引用的处理是一样的，都是传值，所以，如果是传引用的方法调用，也同时可以理解为"传引用值"
的传值调用，即引用的处理跟基本类型是完全一样的。但是当进入被调用方法时，被传递的这个引用的值，被程序解释(或
者查找)到堆中的对象，这个时候才对应到真正的对象。如果此时进行修改，修改的是引用对应的对象，而不是引用本身，
即: 修改的是堆中的数据。

对象，从某种意义上说，是由基本类型组成的。可以把一个对象看作为一棵树，对象的属性如果还是对象，则还是一颗树(即
非叶子节点)，基本类型则为树的叶子节点。程序参数传递时，被传递的值本身都是不能进行修改的，但是，如果这个值是一
个非叶子节点(即一个对象引用)，则可以修改这个节点下面的所有内容。

---------------------------------------------------------------------------------------------------------------
JVM内存模型中Heap区分两大块，一块是 Young Generation，另一块是Old Generation

1)在Young Generation中，有一个叫Eden Space的空间，主要是用来存放新生的对象，还有两个Survivor Spaces(from、to)，
它们的大小总是一样，它们用来存放每次垃圾回收后存活下来的对象。
2)在Old Generation中，主要存放应用程序中生命周期长的内存对象。
3)在Young Generation块中，垃圾回收一般用Copying的算法，速度快。每次GC的时候，存活下来的对象首先由Eden拷贝到某个
SurvivorSpace，当Survivor Space空间满了后，剩下的live对象就被直接拷贝到OldGeneration中去。因此，每次GC后，Eden
内存块会被清空。
4)在Old Generation块中，垃圾回收一般用mark-compact的算法，速度慢些，但减少内存要求。
5)垃圾回收分多级，0级为全部(Full)的垃圾回收，会回收OLD段中的垃圾；1级或以上为部分垃圾回收，只会回收Young中的垃圾，
内存溢出通常发生于OLD段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。

---------------------------------------------------------------------------------------------------------------

堆和栈中，栈是程序运行最根本的东西。程序运行可以没有堆，但是不能没有栈。而堆是为栈进行数据存储服务，说白了堆就是一块
共享的内存。不过，正是因为堆和栈的分离的思想，才使得Java的垃圾回收成为可能。

Java中，栈的大小通过-Xss来设置，当栈中存储数据比较多时，需要适当调大这个值，否则会出现java.lang.StackOverflowError异常。
常见的出现这个异常的是无法返回的递归，因为此时栈中保存的信息都是方法返回的记录点。

