
Java内存模型(Java Memory Model，JMM)

JVM规范中试图定义一种Java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下
都能达到一致的内存访问效果。

Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样
的底层细节。(这里说的变量包括实例字段、静态字段和构成数组对象的元素，不包括局部变量与方法参数，因为后者是
线程私有的，不会共享，也就不存在竞争的问题。)

Java内存模型规定了所有的变量都存储在主内存(Main Memory)中，此外每条线程还有自己的工作内存(Working Memory)。

线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作(读取、赋值等)都必须在工
作内存中进行，不能直接读写主内存中的变量。并且，不同的线程之间也无法直接访问对方工作内存中的变量，线程间
变量值的传递均需要通过主内存来完成。

也可以把这里的主内存与工作内存概念与JVM运行时数据区进行对应，主内存主要对应Java堆中的对象实例数据部分，工
作内存对应于虚拟机栈中的部分区域。

-----------------------------------------------------------------------------------------------------------
内存间的交互动作:

lock(锁定)
作用于主内存变量，把一个变量标示为一条线程独占的状态

unlock(解锁)
作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定

read(读取)
作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用

load(载入)
作用于工作内存的变量，把read操作从主存中得到的变量值放入工作内存的变量副本中

use(使用)
作用于工作内存的变量，把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的
字节码指令时将会执行这个操作

assign(赋值)
作用于工作内存的变量，把一个从执行引擎接收到的值赋给工作内存中的变量，每当虚拟机遇到一个给变量赋值的
字节码指令时执行这个操作

store(存储)
作用于工作内存的变量，把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用

write(写入)
作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中

-----------------------------------------------------------------------------------------------------------

Java内存模型中的可见性、原子性和有序性。

1.可见性

通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个
线程之间对内存写入操作的可见性，必须使用同步机制。

可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线
程马上就能看到。比如: 用volatile修饰的变量，就会具有可见性。

volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一
个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0; 之后有一
个操作 a++; 这个变量a具有可见性，但是 a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。

在 Java 中, volatile、synchronized 和 final 实现可见性。　　

2.原子性

原子是世界上的最小单位，具有不可分割性。比如 int a=0; 这个操作是不可分割的，那么我们说这个操作时原子操作。
再比如: a++; 这个操作实际是 a=a+1; 是可分割的，所以它不是一个原子操作。非原子操作都会存在线程安全问题，
需要我们使用同步技术(synchronized)来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。

java的concurrent包下提供了一些原子类，比如: AtomicInteger、AtomicLong、AtomicReference等。

在 Java 中, synchronized 和 lock&unlock 保证原子性。

3.有序性

Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性。
volatile 是因为其本身包含 "禁止指令重排序" 的语义，synchronized 是由 "一个变量在同一个时刻只允许一条线程
对其进行 lock 操作" 这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。

