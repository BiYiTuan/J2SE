
假设某银行只有10个职员。该银行的业务流程分为以下4个步骤:
1）顾客填申请表（5分钟）;
2）职员审核（1分钟）;
3）职员叫保安去金库取钱（3分钟）;
4）职员打印票据，并将钱和票据返回给顾客（1分钟）。

我们看看银行不同的工作方式对其工作效率到底有何影响。

1.BIO方式

每来一个顾客，马上由一位职员来接待处理，并且这个职员需要负责以上4个完整流程。当超过10个顾客时，剩余的顾客需要排队等候。

我们算算这个银行一个小时到底能处理多少顾客？一个职员处理一个顾客需要10分钟（5+1+3+1）时间，一个小时（60分钟）能处理6个
顾客，一共10个职员，那就是只能处理60个顾客。

可以看到银行职员的工作状态并不饱和，比如在第1步，其实是处于等待中。

这种工作方式其实就是BIO，每次来一个请求（顾客），就分配到线程池中由一个线程（职员）处理，如果超出了线程池的最大上限（10
个），就扔到队列等待。

2.NIO方式

如何提高银行的吞吐量呢？

思路：分而治之，将任务拆分开来，由专门的人负责专门的任务。

具体来讲，银行专门指派一名职员A，A的工作就是每当有顾客到银行，他就递上表格让顾客填写，每当有顾客填好表后，A就将其随机指
派给剩余的9名职员完成后续步骤。

我们计算下这种工作方式下银行一个小时到底能处理多少顾客？

假设顾客非常多，职员A的工作处于饱和中，他不断的将填好表的顾客带到柜台处理，柜台一个职员5分钟能处理完一个顾客，一个小时9
名职员能处理：9*（60/5）=108。

可见工作方式的转变能带来效率的极大提升。

这种工作方式其实就NIO的思路。

-------------------------------------------------------------------------------------------------------------------------
典型NIO有三类线程，分别是mainReactor线程、subReactor线程、work线程。

mainReactor线程负责监听server socket，accept新连接，并将建立的socket分派给subReactor；
subReactor可以是一个线程，也可以是线程池（一般可以设置为CPU核数），负责多路分离已连接的socket，读写网络数据，这里的读写
网络数据可类比顾客填表这一耗时动作，对具体的业务处理功能，其扔给worker线程池完成。


http://blog.jobbole.com/88984/



