

NIO 和 IO

NIO 是在jdk1.4开始使用的，它既可以说成"新I/O"，也可以说成非阻塞式I/O。
NIO 和 IO 最大的区别是，IO是面向流的，NIO是面向缓冲区的。


1.面向流与面向缓冲
IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。

2.阻塞与非阻塞IO
IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到数据被读
取或数据完全写入。该线程在此期间不能再干任何事情了。 
NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前
没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可
以继续做其他的事情。非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写
入，这个线程同时可以去做别的事情。线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所
以一个单独的线程现在可以管理多个输入和输出通道(channel)。

-------------------------------------------------------------------------------------------------------
阻塞I/O通信模型 

阻塞I/O在调用 InputStream.read() 方法时是阻塞的，它会一直等到数据到来时(或超时)才会返回; 
同样，在调用 ServerSocket.accept() 方法时，也会一直阻塞到有客户端连接才会返回，每个客户端连
接过来后，服务端都会启动一个线程去处理该客户端的请求。

阻塞I/O通信模型的缺点:
1.当客户端多时，会创建大量的处理线程，且每个线程都要占用栈空间和CPU。
2.阻塞可能带来频繁的上下文切换，且大部分上下文切换可能是无意义的。

-------------------------------------------------------------------------------------------------------
在JDK 1.4之前的I/O系统中，提供的都是面向流的I/O系统，系统一次一个字节地处理数据，面向流的I/O
速度非常慢，而在JDK 1.4中推出了NIO，这是一个面向块的I/O系统，系统以块的方式处理数据，按块处理
要比按字节处理数据快的多。

在NIO中有几个核心对象: 缓冲区(Buffer)、通道(Channel)、选择器(Selector)。

1.缓冲区(Buffer)
缓冲区实际上是一个容器对象，直接的说，其实就是一个数组，在NIO中，所有数据都是用缓冲区处理的。
在读取数据时，它是直接读到缓冲区中的; 在写入数据时，它也是写入到缓冲区中的; 任何时候访问NIO中
的数据，都是将它放到缓冲区中。而在面向流I/O系统中，所有数据都是直接写入或者直接将数据读取到
Stream对象中。

position,
limit,
capacity

2.通道(Channel)
通道是一个对象，通过它可以读取和写入数据。当然, 所有数据都通过Buffer对象来处理。我们不会将字
节直接写入通道中，相反是将数据写入包含一个或者多个字节的缓冲区。同样不会直接从通道中读取字节，
而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。

使用NIO读取数据，任何时候读取数据，都不是直接从通道读取，而是从通道读取到缓冲区。
所以使用NIO读取数据可以分为下面三个步骤:
1)从FileInputStream获取Channel;
2)创建Buffer;
3)将数据从Channel读取到Buffer中。

使用NIO写入数据与读取数据的过程类似，同样数据不是直接写入通道，而是写入缓冲区。
可以分为下面三个步骤:
1)从FileOutputStream获取Channel;
2)创建Buffer;
3)将数据从Channel写入到Buffer中。

-------------------------------------------------------------------------------------------------------
NIO原理及通信模型 

NIO的工作原理:
1.由一个专门的线程来处理所有的 IO 事件，并负责分发。 
2.事件驱动机制: 事件到的时候触发，而不是同步的去监视事件。 
3.线程通讯: 线程之间通过 wait/notify 等方式通讯，保证每次上下文切换都是有意义的，减少无谓的线程切换。 

NIO的服务端只需启动一个专门的线程来处理所有的 IO 事件。
NIO采用了双向通道(channel)进行数据传输，而不是单向的流(stream)，在通道上可以注册事件。

一共有四种事件:
1.服务端接收客户端连接事件  SelectionKey.OP_ACCEPT(16)
2.客户端连接服务端事件	   SelectionKey.OP_CONNECT(8)
3.读事件	                   SelectionKey.OP_READ(1)
4.写事件	                   SelectionKey.OP_WRITE(4)

服务端和客户端各自维护一个管理通道的对象，我们称之为selector，该对象能检测一个或多个通道(channel)上的事件。
以服务端为例，如果服务端的selector上注册了读事件，某时刻客户端给服务端发送了一些数据，阻塞I/O这时会调用read()
方法阻塞地读取数据，而NIO的服务端会在selector中添加一个读事件。服务端的处理线程会轮询地访问selector，如果
访问selector时发现有事件到达，则处理这些事件，如果没有事件到达，则处理线程会一直阻塞直到事件到达为止。

-------------------------------------------------------------------------------------------------------
通常在进行同步I/O操作时，如果读取数据，代码会阻塞直至有可供读取的数据。同样，写入调用将会阻塞直至
数据能够写入。传统的Server/Client模式会基于TPR（Thread per Request）,服务器会为每个客户端请求建
立一个线程，由该线程单独负责处理一个客户请求。这种模式带来的一个问题就是线程数量的剧增，大量的线程
会增大服务器的开销。大多数的实现为了避免这个问题，都采用了线程池模型，并设置线程池的最大线程数量，
这也带来了新的问题，如果线程池中有200个线程，而有200个用户都在进行大文件下载，会导致第201个用户的
请求无法及时处理，即便第201个用户只想请求一个几KB大小的页面。


NIO中非阻塞I/O采用了基于Reactor模式的工作方式，I/O调用不会被阻塞，相反是注册感兴趣的特定I/O事件，
如可读数据到达、新的套接字连接等等，在发生特定事件时，系统再通知我们。NIO中实现非阻塞I/O的核心对
象就是Selector，Selector就是注册各种I/O事件的地方，而且当那些事件发生时，就是这个对象告诉我们所
发生的事件。

1.向Selector对象注册感兴趣的事件 
2.从Selector中获取感兴趣的事件 
3.根据不同的事件进行相应的处理

-------------------------------------------------------------------------------------------------------

Netty、Mina



http://blog.jobbole.com/88984/

