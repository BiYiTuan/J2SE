
可见性: 
一个线程对共享变量值的修改，能够及时地被其他线程看到。

共享变量:
如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量。

实现共享变量的可见性，必须保证:
1.线程修改后的共享变量值能够及时从工作内存刷新到主内存中。
2.其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中。

导致共享变量在线程间不可见的原因:
1.线程的交叉执行
2.重排序结合线程交叉执行
3.共享变量未及时更新(共享变量更新后的值没有在工作内存与主内存间及时更新)

Java语言层面支持的可见性实现方式有:
1.synchronized
2.volatile
3.final也支持内存可见性

一、synchronized实现可见性

synchronized能够实现:
1.原子性(同步、互斥锁)
2.可见性

JMM关于synchronized的两条规定:
1.线程解锁前, 必须把共享变量的最新值刷新到主内存中
2.线程加锁时, 将清空工作内存中共享变量的值, 从而使用共享变量时需要从主内存中重新读取最新
的值(注意: 加锁与解锁需要是同一把锁)。
基于以上两点，可以保证，线程解锁前对共享变量的修改在下次加锁时对其他线程可见。

线程执行互斥代码的过程:
1.获得互斥锁
2.清空工作内存
3.从主内存拷贝变量的最新副本到工作内存
4.执行代码
5.将更改后的共享变量的值刷新到主内存
6.释放互斥锁。

补充知识点
1.重排序(指令重排序)
代码书写的顺序与实际执行的顺序不同，指令重排序是编译器或处理器为了提高程序性能而做的优化。

指令重排序有3种:
1)编译器优化的重排序(编译器优化，在单线程中保证结果正确的前提下，对代码顺序的优化)
2)指令级并行重排序(处理器优化)
3)内存系统的重排序(处理器优化, 处理器对读写缓存进行的优化)
其实就是主内存、工作内存和执行引擎之间的读写操作，主要对这一块进行重排序。

as-if-serial:
无论如何重排序，程序执行的结果应该和代码顺序执行的结果一致(Java编译器和处理器都会保证Java在单
线程下遵循as-if-serial语义)。

重排序不会给单线程带来内存可见性问题。但是，在多线程中程序交错执行时，重排序可能会造成内存可见
性问题。

二、volatile实现可见性

深入来说: 通过加入内存屏障和禁止重排序优化来实现的。
1.对volatile变量执行写操作时，处理器会在写操作后加入一条store屏障指令(会把cpu写缓存区的缓存强制刷
新到主内存中，同时防止处理器把volatile变量前面的变量重排序到volatile变量之后)。
2.对volatile变量执行读操作时，会在读操作前加入一条load屏障指令(会强制缓存区的缓存失效，重新从主内
存中读取volatile变量最新的值)。

通俗地讲: volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又
会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值。

线程写volatile变量的过程:
1.改变线程工作内存中volatile变量副本的值
2.将改变后的副本的值从工作内存刷新到主内存

线程读volatile变量的过程:
1.从主内存中读取volatile变量的最新值到线程的工作内存中
2.从工作内存中读取volatile变量的副本

但是，volatile不能保证实现原子性。

volatile适用场景:
1.对变量的写入操作不依赖于其当前值，即改变后的volatile变量的值不能与它之前的值有关系。
不满足: number++、count=count*5 等
满足: boolean变量、记录温度变化的变量等   
2.该变量没有包含在具有其他变量的不变式中，即不能存在通过volatile变量进行逻辑判断。
不满足: 不变式 low<up，up和low都是volatile变量。

补充:
1.即使没有保证可见性的措施，为什么在很多时候共享变量依然能够在主内存和工作内存间得到及时的更新?
答: 一般只有在短时间内高并发的情况下才会出现变量得不到及时更新的情况，因为CPU在执行时会很快地刷新缓
存(cache)，所以一般情况下很难遇到这种问题。但是，正是因为这种情况不可预测，所以我们才需要做一些措施
来保证可见性。

2.为什么说对于64位(long、double)变量的读写可能不是原子操作?
答: 因为Java内存模型允许JVM将没有被volatile修饰的64位数据类型的读写操作划分为两次32位的读写操作来进
行。所以会导致有可能出现读取到"半个变量"的情况，解决方法就是加volatile关键字。实际上，很多商用平台的
虚拟机已经把64位的操作当成原子操作来对待了，所以我们在使用时可以忽略，只需了解即可。

------------------------------------------------------------------------------------------------
原子性

操作变量的操作是"原子的"，该操作不可再分，因此是线程安全的。

在Java5之前，可以通过volatile、synchronized关键字来解决并发访问的安全问题，但这样太麻烦。
Java5之后，专门提供了用来进行单变量多线程并发安全访问的工具包java.util.concurrent.atomic。


保证自增操作原子性的解决方案:
1.使用synchronized关键字
2.使用ReentrantLock (java.util.concurrent.locks 包下)
3.使用AtomicInteger (java.util.concurrent.atomic 包下)




