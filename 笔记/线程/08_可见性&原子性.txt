
可见性: 
一个线程对共享变量值的修改，能够及时地被其他线程看到。

共享变量:
如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量。

实现共享变量的可见性，必须保证:
1.线程修改后的共享变量值能够及时从工作内存刷新到主内存中
2.其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中

导致共享变量在线程间不可见的原因:
1.线程的交叉执行
2.重排序结合线程交叉执行
3.共享变量未及时更新(共享变量更新后的值没有在工作内存与主内存间及时更新)

Java语言层面支持的可见性实现方式有:
1.synchronized
2.volatile

一、synchronized实现可见性

synchronized能够实现:
1.原子性(同步、互斥锁)
2.可见性

JMM关于synchronized的两条规定:
1.线程解锁前, 必须把共享变量的最新值刷新到主内存中
2.线程加锁时, 将清空工作内存中共享变量的值, 从而使用共享变量时需要从主内存中重新读取最新
的值(注意:加锁与解锁需要是同一把锁)。
基于以上两点，可以保证，线程解锁前对共享变量的修改在下次加锁时对其他线程可见。

线程执行互斥代码的过程:
1.获得互斥锁
2.清空工作内存
3.从主内存拷贝变量的最新副本到工作内存
4.执行代码
5.将更改后的共享变量的值刷新到主内存
6.释放互斥锁。

补充知识点
1.重排序(指令重排序)
代码书写的顺序与实际执行的顺序不同，指令重排序是编译器或处理器为了提高程序性能而做的优化。

指令重排序有3种:
1)编译器优化的重排序(编译器优化，在单线程中保证结果正确的前提下，对代码顺序的优化)
2)指令级并行重排序(处理器优化)
3)内存系统的重排序(处理器优化, 处理器对读写缓存进行的优化)
其实就是主内存、工作内存和执行引擎之间的读写操作，主要对这一块进行重排序。

as-if-serial:
无论如何重排序，程序执行的结果应该和代码顺序执行的结果一致(Java编译器和处理器都会保证Java在单
线程下遵循as-if-serial语义)。

重排序不会给单线程带来内存可见性问题。但是，在多线程中程序交错执行时，重排序可能会造成内存可见
性问题。

二、volatile实现可见性



------------------------------------------------------------------------------------------------
原子性





