

HashMap底层实现

对于 HashMap 而言，系统把 key-value 当成一个整体(Map.Entry)进行处理，这个整体就是一个 Entry 对象。系统根
据 Hash 算法来计算 key-value 的存储位置，这样可以保证能快速存、取 Map 的 key-value 对。

HashMap底层是一个数组结构(Entry[])，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。

HashMap实际上是一个"链表散列"的数据结构，即数组和链表的结合体。

---------------------------------------------------------------------------------------------------
put(存)
往HashMap中put元素的时候，先根据key的hashCode计算hash值，根据hash值得到这个元素在数组(table)中的位置(即下标)，
如果数组中该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的
放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。

get(取)
从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的
链表中找到需要的元素。

总结:
HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数
组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据hash算法来决定其在数组中的存储位置，再根据equals
方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据hash算法找到其在数组中的存储位置，再
根据equals方法从该位置上的链表中取出该Entry。

---------------------------------------------------------------------------------------------------
resize(rehash)

当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要
对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，而在HashMap数组扩容之后，最消
耗性能的点就出现了: 原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。

那么HashMap什么时候进行扩容呢? 当HashMap中的元素个数超过数组大小*loadFactor时，就会进行数组扩容，loadFactor的默认
值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16*0.75=12的时候，就
把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果
我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。

transfer 方法
tranfer方法将所有的元素重新哈希，因为新的容量变大，所以每个元素的哈希值和位置都是不一样的。

---------------------------------------------------------------------------------------------------
注意:
1.不要在并发场景中使用HashMap
2.如果数据大小是固定的，那么最好给HashMap设定一个合理的容量值
